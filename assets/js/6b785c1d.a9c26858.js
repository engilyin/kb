"use strict";(self.webpackChunkalex_ilin_kb=self.webpackChunkalex_ilin_kb||[]).push([[5513],{9695:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Job/TechInterview/Java/core/java-8","title":"java-8","description":"Java 8","source":"@site/docs/Job/TechInterview/Java/core/java-8.md","sourceDirName":"Job/TechInterview/Java/core","slug":"/Job/TechInterview/Java/core/java-8","permalink":"/kb/Job/TechInterview/Java/core/java-8","draft":false,"unlisted":false,"editUrl":"https://github.com/engilyin/kb/docs/Job/TechInterview/Java/core/java-8.md","tags":[],"version":"current","lastUpdatedAt":1727972934000,"frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"garbage-collection","permalink":"/kb/Job/TechInterview/Java/core/garbage-collection"},"next":{"title":"java-memory-model","permalink":"/kb/Job/TechInterview/Java/core/java-memory-model"}}');var l=r(4848),i=r(8453);const s={},o=void 0,a={},c=[{value:"Java 8",id:"java-8",level:2},{value:"Streams",id:"streams",level:3},{value:"Examples:",id:"examples",level:3},{value:"Comparators",id:"comparators",level:3},{value:"Concurrency",id:"concurrency",level:3},{value:"CompletableFuture",id:"completablefuture",level:3},{value:"StampedLock",id:"stampedlock",level:3},{value:"@Contended",id:"contended",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"java-8",children:"Java 8"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#streams",children:"Streams"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#examples-",children:"Examples:"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#comparators",children:"Comparators"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#concurrency",children:"Concurrency"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#completablefuture",children:"CompletableFuture"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#stampedlock",children:"StampedLock"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#-contended",children:"@Contended"})}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"streams",children:"Streams"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Create"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Stream.of(T\u2026 a)"}),"\n",(0,l.jsx)(n.li,{children:"IntStream.rangeClosed(start, end)  + LongStream & DoubleStream"}),"\n",(0,l.jsx)(n.li,{children:"Arrays.stream(array)"}),"\n",(0,l.jsx)(n.li,{children:"list.stream()"}),"\n",(0,l.jsx)(n.li,{children:"list.parallelStream()"}),"\n",(0,l.jsx)(n.li,{children:"Files.getLines()"}),"\n",(0,l.jsx)(n.li,{children:"Stream.generate(() -> Math.random());"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Filter"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"findAny"}),"\n",(0,l.jsx)(n.li,{children:"findFirst"}),"\n",(0,l.jsx)(n.li,{children:"filter"}),"\n",(0,l.jsx)(n.li,{children:"distinct"}),"\n",(0,l.jsx)(n.li,{children:"limit(long)"}),"\n",(0,l.jsx)(n.li,{children:"skip(long)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Operations"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"sorted"}),"\n",(0,l.jsx)(n.li,{children:"boxed"}),"\n",(0,l.jsx)(n.li,{children:"min(comparator)"}),"\n",(0,l.jsx)(n.li,{children:"max(comparator)"}),"\n",(0,l.jsx)(n.li,{children:"count"}),"\n",(0,l.jsx)(n.li,{children:"forEach"}),"\n",(0,l.jsx)(n.li,{children:"flatMap  // when each element maps to n elements"}),"\n",(0,l.jsx)(n.li,{children:"toArray"}),"\n",(0,l.jsx)(n.li,{children:"reduce (0, (c, e) -> c + e);   // accumulator, reducer function"}),"\n",(0,l.jsx)(n.li,{children:"reduce (0, Integer::sum);"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Collectors"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Collectors.toList()"}),"\n",(0,l.jsx)(n.li,{children:"Collectors.toSet()"}),"\n",(0,l.jsx)(n.li,{children:"Collectors.toMap(keyMapper, valueMapper)"}),"\n",(0,l.jsx)(n.li,{children:"Collectors.toCollection(TreeSet::new)"}),"\n",(0,l.jsx)(n.li,{children:'Collectors.joining(", ")   // needs stream of strings, use map(Object::toString) before this'}),"\n",(0,l.jsx)(n.li,{children:"Collectors.summingInt(Employee::getSalary)"}),"\n",(0,l.jsx)(n.li,{children:"Collectors.averagingInt(Employee::getSalary)"}),"\n",(0,l.jsx)(n.li,{children:"Collectors.summarizingInt(Employee::getSalary)  [gives stats max,min,count,average]"}),"\n",(0,l.jsx)(n.li,{children:"Collectors.groupingBy(Employee::getDepartment)"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"examples",children:"Examples:"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"FlatMap"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:' Stream<String> lines = Files.lines(path, StandardCharsets.UTF_8);\n Stream<String> words = lines.flatMap(line -> Stream.of(line.split(" +")));\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Typical"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"books.stream()\n       .filter(book -> book.year > 2005)  // filter out books published in or before 2005\n       .map(Book::getAuthor)              // get the list of authors for the remaining books\n       .filter(Objects::nonNull)          // remove null authors from the list\n       .map(Author::getName)              // get the list of names for the remaining authors\n       .forEach(System.out::println);     // print the value of each remaining element\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Read Large File"})}),"\n",(0,l.jsx)(n.p,{children:"Does not load whole file in memory. Though exceptions are wrapped in UncheckedIOException."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"try(Stream<String> stream : Files.lines(Paths.get(\u201cabsolute-path\u201d))){\n   stream.forEach(System.out::println);  \n}\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Group By"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:"Map<Person.Sex, List<Person>> byGender \n    = roster.stream().collect(Collectors.groupingBy(Person::getGender));\n\nConcurrentMap<Person.Sex, List<Person>> byGender \n    = roster.parallelStream().collect(Collectors.groupingByConcurrent(Person::getGender))\n\n// Group employees by department\nMap<Department, List<Employee>> byDept\n    = employees.stream().collect(Collectors.groupingBy(Employee::getDepartment));\n\n// Compute sum of salaries by department\nMap<Department, Integer> totalByDept  \n    = employees.stream().collect(Collectors.groupingBy(Employee::getDepartment,Collectors.summingInt(Employee::getSalary)));\n\n// Partition students into passing and failing\nMap<Boolean, List<Student>> passingFailing \n    = students.stream().collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD));\n"})}),"\n",(0,l.jsx)(n.h3,{id:"comparators",children:"Comparators"}),"\n",(0,l.jsxs)(n.p,{children:["vehicles.sort(Comparator.comparing(Vehicle::getWheels));\nvehicles.sort(Comparator.comparing(Vehicle::getWheels));\nvehicles.sort(Comparator.comparing(Vehicle::getWheels).thenComparing(Vehicle",":getColor",");  //chaining"]}),"\n",(0,l.jsx)(n.h3,{id:"concurrency",children:"Concurrency"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"HashMap"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"compute"}),"\n",(0,l.jsx)(n.li,{children:"computeIfPresent (blocking, so write smaller computations)"}),"\n",(0,l.jsx)(n.li,{children:"computeIfAbsent (blocking, so write smaller computations)"}),"\n",(0,l.jsx)(n.li,{children:"putIfAbsent"}),"\n",(0,l.jsx)(n.li,{children:"merge"}),"\n",(0,l.jsx)(n.li,{children:"getOrDefault (k, def)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Adders/Accumulators"})}),"\n",(0,l.jsx)(n.p,{children:"Much more performant than AtomicLong (have single copy across threads). Accumulators, each thread has own copy tracking its own counter, and when retrieval is triggered in any thread, all threads coordinate and perform total sum of all threads\u2019 counts."}),"\n",(0,l.jsx)(n.p,{children:"Basically no contention, during increment, decrement, add, thus much faster."}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"LongAdder"}),"\n",(0,l.jsx)(n.li,{children:"DoubleAdder"}),"\n",(0,l.jsx)(n.li,{children:"LongAccumulator"}),"\n",(0,l.jsx)(n.li,{children:"DoubleAccumulator"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Operations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"increment"}),"\n",(0,l.jsx)(n.li,{children:"decrement"}),"\n",(0,l.jsx)(n.li,{children:"add (long)"}),"\n",(0,l.jsx)(n.li,{children:"sum  // retrieves result by coordinating between threads"}),"\n",(0,l.jsx)(n.li,{children:"reset"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"completablefuture",children:"CompletableFuture"}),"\n",(0,l.jsxs)(n.p,{children:["Similar to JavaScript promises. Multiple async tasks can be chained (performed one after another on separate thread). Better alternative to ",(0,l.jsx)(n.code,{children:"future"})," where the method ",(0,l.jsx)(n.code,{children:"get"})," is blocking (waits indefinitely for the result). In completableFuture the current thread is not blocked. Each task is executed once previous task is completed."]}),"\n",(0,l.jsx)(n.p,{children:"Also, the program itself becomes more readable."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-java",children:" CompletableFuture.supplyAsync(() -> getStockInfo(\u201cGOOGL\u201d), executor)   // if executor is not passed it uses internal pool\n        .whenComplete((info, exec) -> System.out.println(info))  // triggered once previous operation is finished\n        .thenApply(Stock::getRate)   \n        .thenAccept(rate -> System.out.println(rate))  \n        .thenRun(() -> System.out.println(\u201cdone\u201d)));  \n"})}),"\n",(0,l.jsx)(n.p,{children:"So when you trigger this, it immediately returns the CompletableFuture instance, which can be used to check its status and such."}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["supply method takes ",(0,l.jsx)(n.code,{children:"Supplier"})," which returns a value"]}),"\n",(0,l.jsxs)(n.li,{children:["thenApply method argument is ",(0,l.jsx)(n.code,{children:"Function"})," which takes input and returns value"]}),"\n",(0,l.jsxs)(n.li,{children:["thenAccept method argument is ",(0,l.jsx)(n.code,{children:"Consumer"})," which takes input"]}),"\n",(0,l.jsxs)(n.li,{children:["thenRun method argument is ",(0,l.jsx)(n.code,{children:"Runnable"})," which only runs"]}),"\n",(0,l.jsx)(n.li,{children:"CompletableFuture has no control of tasks while they are running in the executor. So cancel method just sets returned value as Exceptional."}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"stampedlock",children:"StampedLock"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Better alternative for ReadWriteLock"}),"\n",(0,l.jsx)(n.li,{children:"It does optimistic reads so works faster only on less contended operations"}),"\n",(0,l.jsx)(n.li,{children:"Not re-entrant"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"contended",children:"@Contended"}),"\n",(0,l.jsx)(n.p,{children:"For fields shared within same cache line and if only 1 field in it is volatile, then for multiple threads, the cache line will be flushed and will be updated. Thus use of cache is of no use.\nTo fix this, set the field to hot field by using @Contented so that JVM can pad the field so that it takes entire cache line and is not shared with other fields."}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.a,{href:"https://www.youtube.com/watch?v=Q_0_1mKTlnY",children:"Talk explaining the @Contented"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var t=r(6540);const l={},i=t.createContext(l);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);