"use strict";(self.webpackChunkalex_ilin_kb=self.webpackChunkalex_ilin_kb||[]).push([[2572],{4926:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var i=n(4848),o=n(8453);const r={},s="Complexity: Big O Notation",a={id:"Job/TechInterview/complexity",title:"Complexity: Big O Notation",description:"Source//blog.bytebytego.com/p/ep132-big-o-notation-101-the-secret",source:"@site/docs/Job/TechInterview/complexity.md",sourceDirName:"Job/TechInterview",slug:"/Job/TechInterview/complexity",permalink:"/kb/Job/TechInterview/complexity",draft:!1,unlisted:!1,editUrl:"https://github.com/engilyin/kb/docs/Job/TechInterview/complexity.md",tags:[],version:"current",lastUpdatedAt:1754240444e3,frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Testing",permalink:"/kb/Job/TechInterview/Java/spring/testing"},next:{title:"Tech Interview DB",permalink:"/kb/Job/TechInterview/db-tech-interview"}},l={},c=[];function h(e){const t={a:"a",h1:"h1",header:"header",p:"p",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"complexity-big-o-notation",children:"Complexity: Big O Notation"})}),"\n",(0,i.jsxs)(t.p,{children:["Source: ",(0,i.jsx)(t.a,{href:"https://blog.bytebytego.com/p/ep132-big-o-notation-101-the-secret",children:"https://blog.bytebytego.com/p/ep132-big-o-notation-101-the-secret"})]}),"\n",(0,i.jsxs)(t.p,{children:["Also check that out for more: ",(0,i.jsx)(t.a,{href:"https://blog.bytebytego.com/archive?sort=new",children:"https://blog.bytebytego.com/archive?sort=new"})]}),"\n",(0,i.jsx)(t.p,{children:"1 - O(1)\nThis is the constant time notation. The runtime remains steady regardless of input size. For example, accessing an element in an array by index and inserting/deleting an element in a hash table."}),"\n",(0,i.jsx)(t.p,{children:"2 - O(n)\nLinear time notation. The runtime grows in direct proportion to the input size. For example, finding the max or min element in an unsorted array."}),"\n",(0,i.jsx)(t.p,{children:"3 - O(log n)\nLogarithmic time notation. The runtime increases slowly as the input grows. For example, a binary search on a sorted array and operations on balanced binary search trees."}),"\n",(0,i.jsx)(t.p,{children:"4 - O(n^2)\nQuadratic time notation. The runtime grows exponentially with input size. For example, simple sorting algorithms like bubble sort, insertion sort, and selection sort."}),"\n",(0,i.jsx)(t.p,{children:"5 - O(n^3)\nCubic time notation. The runtime escalates rapidly as the input size increases. For example, multiplying two dense matrices using the naive algorithm."}),"\n",(0,i.jsx)(t.p,{children:"6 - O(n logn)\nLinearithmic time notation. This is a blend of linear and logarithmic growth. For example, efficient sorting algorithms like merge sort, quick sort, and heap sort"}),"\n",(0,i.jsx)(t.p,{children:"7 - O(2^n)\nExponential time notation. The runtime doubles with each new input element. For example, recursive algorithms solve problems by dividing them into multiple subproblems."}),"\n",(0,i.jsx)(t.p,{children:"8 - O(n!)\nFactorial time notation. Runtime skyrockets with input size. For example, permutation-generation problems."}),"\n",(0,i.jsx)(t.p,{children:"9 - O(sqrt(n))\nSquare root time notation. Runtime increases relative to the input\u2019s square root. For example, searching within a range such as the Sieve of Eratosthenes for finding all primes up to n."})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var i=n(6540);const o={},r=i.createContext(o);function s(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);